    def search_helper(self, curr_position, dist_left, init_dist, path, paths, color, board):
        if dist_left < 1:
            return
        x, y = curr_position
        if not board.state[x, y] > -1:
            if dist_left == 1 and \
                    board.state[x, y].init_dist == init_dist and \
                    board.state[x, y].color == color:
                paths.append(path + [curr_position])
            return

        if x != board.board_w - 1 and (x + 1, y) not in path and not board.state[x + 1, y] != 0:
            self.search_helper((x + 1, y), dist_left - 1, init_dist, path + [curr_position], paths, color, board)
        if y != board.board_h - 1 and (x, y + 1) not in path and not board.state[x, y + 1] != 0:
            self.search_helper((x, y + 1), dist_left - 1, init_dist, path + [curr_position], paths, color, board)
        if x != 0 and (x - 1, y) not in path and not board.state[x - 1, y] != 0:
            self.search_helper((x - 1, y), dist_left - 1, init_dist, path + [curr_position], paths, color, board)
        if y != 0 and (x, y - 1) not in path and not board.state[x, y - 1] != 0:
            self.search_helper((x, y - 1), dist_left - 1, init_dist, path + [curr_position], paths, color, board)

    def calculate_paths(self, board):
        self.paths = []
        x, y = self.x, self.y
        if x != board.board_w - 1 and not board.state[x + 1, y] != 0:
            self.search_helper((x + 1, y), self.length - 1, self.length, [(x, y)], self.paths, self.color, board)
        if y != board.board_h - 1 and not board.state[x, y + 1] != 0:
            self.search_helper((x, y + 1), self.length - 1, self.length, [(x, y)], self.paths, self.color, board)
        if x != 0 and not board.state[x - 1, y] != 0:
            self.search_helper((x - 1, y), self.length - 1, self.length, [(x, y)], self.paths, self.color, board)
        if y != 0 and not board.state[x, y - 1] != 0:
            self.search_helper((x, y - 1), self.length - 1, self.length, [(x, y)], self.paths, self.color, board)
        return self.paths









    def calculate_paths_helper(self, x, y, length, color, board, path, first_call=False):
        def reached_dest(value):
            return length == 1 and isinstance(value, Clue) and value.color == color and self.length == value.length

        def step_check(x2, y2):
            return board.is_valid_position(x2, y2) and (x2, y2) not in path and length > 1  #board.get(x2, y2) == 0

        # Check if length or position invalid, or already visited node
        if length < 1 or not board.is_valid_position(x, y) or (x, y) in path:
            return

        # Check if we reached destination
        if reached_dest(board.get(x, y)):
            self.paths.append(path + [(x, y)])
            return

        # Check if we hit a clue with wrong length
        if not first_call and (length == 1 or board.get(x, y) != 0):
            return

        if step_check(x + 1, y):
            self.calculate_paths_helper(x + 1, y, length - 1, color, board, path + [(x, y)])
        if step_check(x - 1, y):
            self.calculate_paths_helper(x - 1, y, length - 1, color, board, path + [(x, y)])
        if step_check(x, y + 1):
            self.calculate_paths_helper(x, y + 1, length - 1, color, board, path + [(x, y)])
        if step_check(x, y - 1):
            self.calculate_paths_helper(x, y - 1, length - 1, color, board, path + [(x, y)])